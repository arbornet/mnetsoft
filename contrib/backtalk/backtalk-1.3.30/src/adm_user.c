/* Copyright 1996, Jan D. Wolter and Steven R. Weiss, All Rights Reserved. */

#include "backtalk.h"

#include <pwd.h>
#include <errno.h>
#include "lock.h"
#include "adm.h"
#include "udb.h"
#include "dict.h"
#include "nextuid.h"
#include "adm_check.h"
#include "udb_check.h"
#include "ps_part.h"
#include "group.h"
#include "user.h"
#include "file.h"
#include "stack.h"
#include "free.h"
#include "sysdict.h"
#include "partdir.h"

#ifdef DMALLOC
#include "dmalloc.h"
#endif


extern int errno;
extern char *effective_user;	/* set by "selectuser" */
extern char *new_fname;		/* new fullname set by "changename" */
extern struct passwd *upw;

static char *check_user(char *lid, char *pw, char *fn);
static void savebio(char *login, char *dir, Token *vars);
static void acctlog(char *lid, char *fn, char *dir, gid_t gid);

/* FUNC_NEWUSER:  <login> <passwd> <fullname> <group> <vararray> newuser <err>
 *
 * Create a user account.  Also creates a .backtalk file containing just the
 * registration date.  Group can be an string or an integer.  The vararray
 * is passed to a call like "(*.backtalk) <vararray> savevar".
 *
 * On success, err is an empty string.  Otherwise it is a sequence of
 * newline separated error messages.
 */

#if NOPWEDIT
void func_newuser() { die("Cannot create real unix accounts"); }
#else

void func_newuser()
{
    Token gt;
    char *lid, *fn, *pw, *email;
    char *err;
    char bf[BFSZ+1], dir[BFSZ];
    int am_gradm= 0, am_anon= (*sdict(VAR_ID) == '\0');
    int gid, user_gid, oddgroup;
    int status= 0;
    Token vars;

    /* Get array of literals */
    pop_litarray(&vars);

    /* Get group name or ID and convert to gid */
    pop_any(&gt);
    if (type(gt) == TK_INTEGER)
    	gid= ival(gt);
    else if (type(gt) == TK_STRING)
    {
    	char *group= sval(gt);
	if ((gid= groupid(group)) < 0)
	    die("Group '%s' does not exist",group);
    	free(group);
    }
    else
    	die("expected string or integer argument for group");

    /* Get other args */
    pw= pop_string();
    fn= pop_string();
    lid= pop_string();

    /* Check account creation rights */

    if (!bdict(VAR_AMADM))
    {
	if (idict(VAR_NEWUSEROPEN) == 0)
	{
	    /* Accounts can be created only by cfadm and gradm */

	    am_gradm= user_gradm();
	    /* anonymous and non-gradm accounts blocked, unless
	     * we are creating the system's first account
	     */
	    if ((am_anon || !am_gradm) && next_uid(0) > 1)
		die("Only administrators can create accounts");
	}

	/* Accounts can be created anonymously */

	/* Only cfadm and gradm can create in groups other than 'user' */
	oddgroup= (gid != user_group_id());
	if (oddgroup && !am_anon)
	    am_gradm= user_gradm();

	/* Gradm can create in non-gradm groups that they are members of */
	if (oddgroup &&
	   (!am_gradm || gid == gradm_group_id() ||
	    !ingroupno(gid,idict(VAR_GID),sdict(VAR_ID)) ) )
		die("%s %s in group %d cannot create accounts in group %d",
		    am_gradm ? "Group admin":"User",
		    sdict(VAR_ID),idict(VAR_GID),gid);

	/* If non-cfadm, non-gradm is creating an account, it may be unvalid */
	if (!am_gradm && idict(VAR_NEWUSEROPEN) == 1)
	    status= 1;
    }
	    	
    /* Check user information for sanity */
    if ((err= check_user(lid, pw, fn)) != NULL)
    {
	push_string(err, FALSE);
	return;
    }

    /* In the rare case that email addresses get stored in the identity
     * database, check the variable array to see if /email is there and
     * if it is, get the value out of the dictionary.
     */
    email= NULL;
    if (save_email())
    {
	int i;
	for (i= 0; i < aval(vars)->sz; i++)
	    if (type(aval(vars)->a[i]) == TK_UNBOUND_LITERAL &&
		!strcmp(sval(aval(vars)->a[i]),"email"))
	    {
		Token *t= get_dict("email");
		if (type(*t) == TK_STRING) email= sval(*t);
		break;
	    }
    }

    /* Create conference account (note that 'dir' is generated by adduser) */
    adduser(lid, gid, pw, fn, status, dir, email);
    acctlog(lid,fn,dir,gid);		/* has to be after adduser for dir */
    savebio(lid, dir, &vars);		/* this makes .backtalk file */

    free(pw);
    free(fn);
    free(lid);
    free_val(&vars);

    push_string("", TRUE);
}


/* CHECK_USER - Check the login id, passwords and fullname for a user.
 * If they are OK, return NULL.  Otherwise, return a pointer to an
 * error message string.  This tries to find all possible errors and
 * return a concatination of all error messages, since we are in a batch
 * mode.  The error message string is in malloced memory and should be
 * freed by the caller (assuming you don't just exit immediately).
 */

static char *check_user(char *lid, char *pw, char *fn)
{
    char *error_mesg= (char *)malloc(BFSZ);
    char *err= error_mesg;
    int len, rc= 0;

    /* Check login */
    if (rc= login_bad(lid, err))
    {
	error_mesg= realloc(error_mesg, (len= strlen(error_mesg)) + BFSZ);
	err= error_mesg + len;
    }

    if (getpassword(lid,FALSE) != NULL)
    {
	sprintf(err,"Login %s is already in use.\n",lid);
	error_mesg= realloc(error_mesg, (len= strlen(error_mesg)) + BFSZ);
	err= error_mesg + len;
	rc++;
    }

    /* Check fullname */
    if (fullname_bad(fn, err))
    {
	error_mesg= realloc(error_mesg, (len= strlen(error_mesg)) + BFSZ);
	err= error_mesg + len;
	rc++;
    }

    /* Check password */
    rc+= passwd_bad(pw, lid, err);
    
    if (rc == 0)
    {
	free(error_mesg);
	return NULL;
    }
    else
	return error_mesg;
}


static void savebio(char *login, char *dir, Token *vars)
{
    char fname[BFSZ];
    FILE *fp;

#ifdef PART_DIR
    bbspartpath(fname,login,".backtalk");
    mkpartdir(fname);
#else
    sprintf(fname,"%s/.backtalk", dir);
#endif

    /* Open the file - may have to create directory */
    if ((fp= fopen(fname,"w")) == NULL)
	die("could not create .backtalk file %s (%s)", fname, strerror(errno));

    /* First write out the registration date */
    fprintf(fp,"regdate=%ld\n",time(0L));
    fclose(fp);

    /* Then call savevar to write out the rest */
    do_savevar(fname,vars);
}


static void acctlog(char *lid, char *fn, char *dir, gid_t gid)
{
    char *var, *val;
    FILE *fp;
    time_t clock= time(0L);

    if ((fp= fopen(ACCT_LOG_FILE,"a")) == NULL)
	return;
    lock_exclusive(fileno(fp),ACCT_LOG_FILE);

    fprintf(fp,"-- %15.15s newuser: %s (%s)\n gid=%d dir=%s rhost=",
	ctime(&clock)+4,lid,fn,gid,dir);

    if ((val= getenv("REMOTE_HOST")) != NULL)
	fprintf(fp, "%s", val);
    if ((val= getenv("REMOTE_ADDR")) != NULL)
	fprintf(fp, " (%s)", val);
    fputc('\n',fp);

    fclose(fp);
    unlock(ACCT_LOG_FILE);
}
#endif /*NOPWEDIT*/


/* CHECK_ADM_OR_GRADM
 * Check if we are adm or gradm for the given user.  Die if we aren't.
 */

static void check_adm_or_gradm(struct passwd *pw)
{
    if (!bdict(VAR_AMADM))
    {
    	if (!user_gradm())
	    die("Am not conference administrator or %s group member",
		gradm_group_name());
    	if (idict(VAR_GID) != pw->pw_gid)
	{
	    char *gn= groupname(idict(VAR_GID));
	    if (gn == NULL)
	        die("You can only edit users in group %d",idict(VAR_GID));
	    else
	        die("You can only edit users in group %s",gn);
        }
    }
}


/* FUNC_SELECTUSER: <loginname> selectuser -
 * Have changename, changepass, and write work on some other user's account
 * instead of your own.  Only the conference administrator can execute this.
 * If given a null string, it reverts to the real user.
 */

void func_selectuser()
{
    char *login= pop_string();
    struct passwd *pw= NULL;

    /* Check if user exists */
    if (login[0] != '\0')
    {
        if ((pw= getdbnam(login)) == NULL)
	    die("User %s does not exist",login);
    	check_adm_or_gradm(pw);
    }

    /* Free the old value */
    if (effective_user != NULL)
	free(effective_user);
    
    /* Save the new value */
    if (login[0] == '\0')
    {
    	free(login);
	effective_user= NULL;
    }
    else
	effective_user= login;
}


/* FUNC_CHANGENAME: <fullname> changename <err>
 * Change the user's full name.  Push an error message if name is bad, or a
 * null string on success.
 */

void func_changename()
{
    char *newname;
    char err[BFSZ];
    struct passwd *pw;

#if NOPWEDIT
    die("Cannot change fullnames on real unix accounts");
#else
    if (effective_user == NULL)
    {
	pw= upw;
	if (pw == NULL)
	    die("Cannot change name of unauthenticated user");
    }
    else
	if ((pw= getdbnam(effective_user)) == NULL)
	    die("Selected user does not exist");

    newname= pop_string();
    if (fullname_bad(newname,err))
    {
	push_string(err, TRUE);
	return;
    }

    change_fname(pw,newname);

    if (effective_user == NULL)
    {
	if (new_fname != NULL) free(new_fname);
	new_fname= newname;
    }
    else
	free(newname);

    push_string("",TRUE);
#endif
}


/* FUNC_CHANGEEMAIL: <address> changeemail <err>
 * Change the user's email address, if it is in the identity database.
 * It usually isn't.  Push an error message if it is bad, or a null string
 * on success.  Actually, there is never an error.
 */

void func_changeemail()
{
    char *newemail= pop_string();
    char err[BFSZ];
    struct passwd *pw;

    /* This test should always be true, since calls to this function are
     * normally optimized away if we aren't saving email.
     */
    if (save_email())
#if NOPWEDIT
	die("Cannot change email address on real unix accounts");
#else
    {
	if (effective_user == NULL)
	{
	    pw= upw;
	    if (pw == NULL)
		die("Cannot change email address of unauthenticated user");
	}
	else
	    if ((pw= getdbnam(effective_user)) == NULL)
		die("Selected user does not exist");

	change_email(pw,newemail);
    }

    push_string("",TRUE);
#endif
}


/* FUNC_CHANGEGROUP: <login> <group> changegroup <err>
 * Change the given user's primary group.  The group can be a groupid number
 * or a group name.  Push an error message if name is bad, or a null string on
 * success.  Only administrators can run this command.
 */

void func_changegroup()
{
#if NOPWEDIT
    die("Cannot change group ids on real unix accounts");
#else
    Token tk;
    int newgid;
    char err[BFSZ];
    char *login;
    struct passwd *pw;

    if (!bdict(VAR_AMADM))
	die("user is not a conference adminstrator");

    pop_any(&tk);
    login= pop_string();

    if ((pw= getdbnam(login)) == NULL)
    {
	sprintf(err,"User %.100s does not exist",login);
	push_string(err,TRUE);
        free(login);
        free_val(&tk);
	return;
    }

    if (type(tk) == TK_INTEGER)
    	newgid= ival(tk);
    else if (type(tk) == TK_STRING)
    {
	char *s= sval(tk);
	if (s[0] == '0' && s[0] <= '9')
	    newgid= atoi(s);
	else if ((newgid= groupid(s)) < 0)
	{
	    sprintf(err,"Group %.100s does not exist",s);
	    push_string(err,TRUE);
	    free_val(&tk);
	    free(login);
	    return;
	}
    }
    else
        die("expected string or integer argument");
    free_val(&tk);

    if (newgid < 0)
    {
	sprintf(err,"negative gid number not legal");
	push_string(err, TRUE);
	free(login);
	return;
    }

    change_gid(pw,newgid);

    push_string("",TRUE);
    free(login);
#endif
}


/* FUNC_CHANGEPASS: <password> changepass <err>
 * Change the user's password.  Push an error message if password is no good,
 * or a null string if it is OK.  This validates the account as a side effect.
 */

void func_changepass()
{
    char err[BFSZ];
    char *newpw;
    struct passwd *pw;

#if NOPWEDIT
    die("Cannot change passwords on real unix accounts");
#else
    if (effective_user == NULL)
    {
	pw= upw;
	if (pw == NULL)
	    die("Cannot change password of unauthenticated user");
    }
    else
	if ((pw= getdbnam(effective_user)) == NULL)
	    die("Selected user does not exist");

    newpw= pop_string();
    if (passwd_bad(newpw,pw->pw_name,err))
    {
	push_string(err, TRUE);
	return;
    }
    change_passwd(pw,mkpasswd(newpw,0));
    free(newpw);
    push_string("",TRUE);
#endif
}


/* FREE_PASSWD - Given a pointer that dup_passwd() once returned, free it.
 */

void free_passwd(struct passwd *pw)
{
    if (pw->pw_name) free(pw->pw_name);
    if (pw->pw_passwd) free(pw->pw_passwd);
    if (pw->pw_gecos) free(pw->pw_gecos);
    if (pw->pw_dir) free(pw->pw_dir);
    if (pw->pw_shell) free(pw->pw_shell);
    free(pw);
}


/* FUNC_REMOVEUSER: - removeuser -
 * Remove the user's account.  Bombs on errors.
 */

void func_removeuser()
{
    char err[BFSZ];
    struct passwd *pw;
#if NOPWEDIT
    die("Cannot remove real unix accounts");
#else

    if (effective_user == NULL)
    {
	pw= upw;
	if (pw == NULL)
	    die("Cannot delete unauthenticated user");
    }
    else
	if ((pw= getdbnam(effective_user)) == NULL)
	    die("Selected user does not exist");

    kill_user(pw);

    if (effective_user == NULL)
    {
	/* Invalidate user data */
	free_passwd(upw);
	upw= NULL;
    }
#endif
}


/* FUNC_VALIDATE: <login> <flag> validate -
 *
 * Change the status of an account.  Validates if <flag> is true, invalidates
 * if <flag> is false.
 */

void func_validate()
{
    int flag, i= 0;
    char *login, *oldpw;
    char newpw[BFSZ];
    struct passwd *pw;

#if NOPWEDIT
    die("Cannot change validation status of real unix accounts");
#else
    flag= pop_integer();
    login= pop_string();

    if ((oldpw= getpassword(login,FALSE)) == NULL ||
	    (pw= getdbnam(login)) == NULL)
	die("user %s does not exist",login);

    check_adm_or_gradm(pw);

    if (oldpw[0] == '*' || oldpw[0] == '?') oldpw++;
    
    if (!flag) newpw[i++]= '*';
    strcpy(newpw+i, oldpw);

    change_passwd(pw, newpw);
#endif
}
