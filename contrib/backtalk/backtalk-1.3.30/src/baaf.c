/* Copyright 2003, Jan D. Wolter and Steven R. Weiss, All Rights Reserved. */

#include "backtalk.h"
#include "sysdict.h"
#include "baaf_core.h"
#include "baaf.h"
#include "stack.h"
#include "str.h"
#include "confaccess.h"

#if ATTACHMENTS

#include <sys/stat.h>
#include <errno.h>
#if HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

extern int errno;


/* OPEN_TEMP_ATTACH - Create a temporary file to write out an attachment to.
 * Return the open file descriptor and the temp filename.  The temp file name
 * is in malloced memory.  Dies on failure.
 */

FILE *open_temp_attach(char **tmpfile)
{
    int fd;
    FILE *fp;
    pid_t pid= getpid();
    time_t tm= time(0L);
    char *tname;
    int i= 0;

    for (;;)
    {
	*tmpfile= (char *) malloc(18);
	sprintf(*tmpfile,"%08X%08X", (unsigned int)pid,(unsigned int)(tm+i));

	tname= (char *) malloc(strlen(ATTACH_DIR)+28);
	sprintf(tname,ATTACH_DIR"tmp/%s",*tmpfile);

	if ((fd= open(tname,O_WRONLY|O_CREAT|O_EXCL,0644)) >= 0)
	    break;

	if (errno == EEXIST && i < 10)
	{
	    i++;
	    continue;
	}
	else
	    die("Could not create file %s: %s", tname, strerror(errno));
    }
    fp= fdopen(fd,"w");
    free(tname);
    return fp;
}


/* TEMP_ATTACH_HANDLE - Return the temporary handle for the attachment with
 * the given tempfile name (generated by open_temp_attach), mime type and
 * original file name.  Returns the handle in malloced memory
 */

char *temp_attach_handle(char *tmpfile, char *origname, char *ctype)
{
    char *handle;

    handle= (char *) malloc(strlen(tmpfile)+strlen(origname)+strlen(ctype)+4);
    sprintf(handle,"%s:%s:%s",tmpfile, origname, ctype);

    return handle;
}


/* MAKE_ATTACH:  Convert a temporary attachment handle into a permanent
 * attachment handle.  File is moved, index entry is created.  Returns new
 * handle in malloced memory.  If rn is -1, then attachment is associated
 * with the full conference (eg, something that gets referenced in the
 * login screen).  If rn is -2, then the attachment is associated with
 * the user.
 */

char *make_attach(char *tmphand, char *desc, char *cf, int in, int rn,
	int access)
{
    char *origname, *type, *p;
    char tmppath[BFSZ], new[BFSZ], *path;
    struct stat st;
    int n= 0;

    /* Parse apart the temp handle */
    if ((origname= strchr(tmphand,':')) == NULL ||
	 (type= strchr(origname+1,':')) == NULL)
	die("Bad syntax for temporary attachment handle '%s'",tmphand);
    *(origname++)= '\0';
    *(type++)= '\0';

    /* Clean up the original file name */
    for (p= origname; *p != '\0'; p++)
	if (!isascii(*p) || !isprint(*p) ||
		strchr(" /*?#!$&(){}|~'\"\\<>;,`",*p) != NULL)
	    *p= '_';

    /* Construct the temporary file name */
    snprintf(tmppath,BFSZ,ATTACH_DIR"tmp/%s",tmphand);

    /* Check that it exists (and get size) */
    if (stat(tmppath, &st))
	die("Cannot access temporary attachment file: %s",tmppath);

    /* Construct new name, and link the file there */
    if (rn == -2)
	sprintf(new,"U_%s/%s", sdict(VAR_ID), origname);
    else if (rn == -1)
	sprintf(new,"%s/%s", cf, origname);
    else
	sprintf(new,"%s-%d-%d/%s", cf, in, rn, origname);

    for (;;)
    {
	/* Make full path name */
	path= baaf_path(new);
	
	if (!link(tmppath, path)) break;

	/* Link failed */
	if (errno == ENOENT)
	{
	    /* Missing parent directories - try to create them */
	    char *p1, *p2;
	    *(p1= strrchr(path,'/'))= '\0';
	    *(p2= strrchr(path,'/'))= '\0';
	    mkdir(path,0700);
	    *p2= '/';
	    mkdir(path,0700);
	    *p1= '/';
	    if (!link(tmppath, path)) break;
	}

	if (errno != EEXIST)
	{
	    /* Some weird error */
	    die("Could not link to file %s: %s",path, strerror(errno));
	}

	/* File already existed:  Next try at a file name */
	free(path);
	n++;
	if (rn == -2)
	    sprintf(new,"U_%s.%d/%s", sdict(VAR_ID), n, origname);
	else if (rn == -1)
	    sprintf(new,"%s.%d/%s", cf, n, origname);
	else
	    sprintf(new,"%s-%d-%d.%d/%s", cf, in, rn, n, origname);
    }

    /* Create the index entry */
    baai_set(new, 0, type, st.st_size, sdict(VAR_ID), sdict(VAR_UID), cf,
	    access, st.st_ctime, (desc[0] != '\0') ?  desc : origname);

    /* Remove the old tmp file */
    if (unlink(tmppath))
	die("Could not unlink temp attach file: %s",tmppath);

    free(path);
    return strdup(new);
}

/* ATTACH_URL: Construct a url by which the given handle may be fetched
 */

char *aturlstr= NULL;	    /* Cached URL of 'backfile' program */
int aturln;		    /* Length of aturlstr */

char *attach_url(char *hand)
{
    char *url;

    if (aturlstr == NULL)
    {
	char *b,*s,*d;
	if ((b= getenv("SCRIPT_NAME")) == NULL)
	{
#ifdef DFLT_SCRIPT_NAME
	    b= DFLT_SCRIPT_NAME;
#else
	    die("SCRIPT_NAME environment variable not defined");
#endif
	}
	if ((s= strrchr(b,'/')) == NULL) s= b-1;
	if ((d= strrchr(b,'.')) != NULL && d < s) d= NULL;
	aturlstr= (char *)malloc(s-b + (d==NULL?0:strlen(d)) + 12);
	strncpy(aturlstr, b, s-b+1);
	strcpy(aturlstr+(s-b+1), "backfile");
	if (d!= NULL) strcpy(aturlstr+(s-b+9), d);
	aturln= strlen(aturlstr);
	aturlstr[aturln++]= '/';
	aturlstr[aturln]= '\0';
    }
    url= (char *)malloc(aturln + strlen(hand) + 1);
    strcpy(url, aturlstr);
    strcpy(url+aturln, hand);
    return url;
}

/* GET_ATTACH:  <handle> get_attach <type> <size> <desc> <url> 0
 *              <handle> get_attach 1	    - Attachment not found
 *              <handle> get_attach 2	    - Permission Denied
 *
 */

void func_get_attach()
{
    char *hand= pop_string();
    char *type, *desc, *conf, *user;
    int access;
    uid_t uid;
    off_t size;

    if (baai_get(hand, NULL, &type, &size, &user, &uid, &conf, &access, NULL,
		&desc))
    {
	push_integer(1);
    }
    else
    {
	if ((access == 1 && *sdict(VAR_ID) == '\0') ||
	    (access == 2 &&
	     (strcmp(user,sdict(VAR_ID)) || uid != idict(VAR_UID)) &&
	     conf_access(conf) > 0 ) )
	{
	    /* Permission denied */
	    free(type);
	    free(user);
	    free(conf);
	    free(desc);

	    push_integer(2);
	}
	else
	{
	    /* Got it */
	    push_string(type,FALSE);
	    push_integer(size);
	    push_string(desc,FALSE);
	    push_string(attach_url(hand),FALSE);
	    push_integer(0);
	}
    }
    free(hand);
}


/* EDIT_ATTACH:  <handle> <newdesc> <newtype> edit_attach <errcode>
 *
 * Change type/description of an attachment.
 */

void func_edit_attach()
{
    char *ntype= pop_string();
    char *ndesc= pop_string();
    char *hand= pop_string();
    char *user, *conf;
    int link, acc;
    off_t size;
    uid_t uid;
    time_t date;

    /* Anonymous users can't edit attachments */
    if (idict(VAR_UID) < 0 || sdict(VAR_ID)[0] == '\0')
    {
	push_integer(2);
    }
    else
    {
	/* Get old values */
	if (baai_get(hand, &link, NULL, &size, &user, &uid,
		    &conf, &acc, &date, NULL))
	{
	    push_integer(1);
	}
	/* Check if we have permission to edit */
	else if ( (!bdict(VAR_AUTHOR_EDIT) ||
		    strcmp(user,sdict(VAR_ID)) ||
		    uid != idict(VAR_UID)) &&
		  (!bdict(VAR_FW_EDIT) || conf_access(conf) > -1) )
	{
	    push_integer(2);
	}
	else
	{
	    /* Set new values */
	    baai_set(hand, link, ntype, size, user, uid,
		    conf, acc, date, ndesc);
	    push_integer(0);
	}
	free(user);
	free(conf);
    }
    free(ntype);
    free(ndesc);
    free(hand);
}


/* BAAF_FILE:  Serve up an actual file.
 */

void baaf_file(char *hand)
{
    char *err, *type, *conf, *path, buf[BFSZ], *user;
    FILE *fp;
    int acc, n;
    uid_t uid;

    if (hand == NULL)
    {
	err="No Filename Given";
	goto dud;
    }

    /* Omit leading /'s from handle */
    while (hand[0] == '/') hand++;

    /* Get info from index */
    if (baai_get(hand, NULL, &type, NULL, &user, &uid, &conf, &acc, NULL, NULL))
    {
	err= "File Not Found";
        goto dud;
    }

    /* Check permissions */
    err= "Permission Denied";
    if (acc == 0)
	err= NULL;
    else if (acc == 1)
    {
	if (*sdict(VAR_ID) != '\0') err= NULL;
    }
    else if (idict(VAR_UID) == uid && !strcmp(sdict(VAR_ID),user))
	err= NULL;
    else if (acc == 2)
    {
	if (conf_access(conf) < 1) err= NULL;
    }

    if (err != NULL) goto dud;

    path= baaf_path(hand);

    if ((fp= fopen(path,"r")) == NULL)
    {
	err= "File Deleted";
	goto dud;
    }

    /* Transmit the content */
    printf("Content-type: %s\n\n",type);
    while ((n= fread(buf, 1, BFSZ, fp)) > 0)
	fwrite(buf, 1, n, stdout);

    fclose(fp);
    free(path);
    return;

dud:printf("Content-Type: text/plain\n\n%s\n",err);
    return;
}
#else
/* No-op functions for when attachments are disabled */
void func_get_attach() {func_pop(); push_integer(1);}
void func_edit_attach() { func_pop(); func_pop(); func_pop(); push_integer(1);}
#endif /* ATTACHMENTS */
