#include "backtalk.h"

#include <ctype.h>

#ifdef DMALLOC
#include "dmalloc.h"
#endif

char *ucname(char *n)
{

    if (isalpha(n[0]) || n[0] == '_' || n[0] == '@')
    {
	static char uc[MAXSYMLEN+4];
	int i= 0, j= 0;

	/* Syntactically illegal symbol names starting an @ are for
	 * internal use - not currently used */
	if (n[0] == '@') {
		if (n[1] == '\0') return "AT";
		strcpy(uc,"INT_");
		i= 1;
		j= 4;
	}

	for ( ; n[i] != '\0'; i++,j++)
	    uc[j]= (islower(n[i]) ? toupper(n[i]) : n[i]);
	uc[j]= '\0';
	return uc;
    }

    switch(n[0])
    {
    case '!': return "NOT";
    case '~': return "BNOT";
    case '?': return "BISEL";
    case '*': return "MUL";
    case '+': return "ADD";
    case '-': return "SUB";
    case '/': return "DIV";
    case '#': return "POUND";
    case '&': return "AMPERSAND";
    case '|': return "BAR";
    case '[': return "LBRACKET";
    case ']': return "RBRACKET";
    case '=': return "EQUALS";
    default: return NULL;
    }
}


void typenames()
{
    /* Define convenience variables with class names */
    printf("set $TK_CLASS=%d\n",TK_CLASS);
    printf("set $TKC_INTEGER=%d\n",TKC_INTEGER);
    printf("set $TKC_TIME=%d\n",TKC_TIME);
    printf("set $TKC_STRING=%d\n",TKC_STRING);
    printf("set $TKC_ARRAY=%d\n",TKC_ARRAY);
    printf("set $TKC_FUNCTION=%d\n",TKC_FUNCTION);
    printf("set $TKC_REGEX=%d\n",TKC_REGEX);
    printf("set $TKC_DICT=%d\n",TKC_DICT);
    printf("set $TKC_NONE=%d\n",TKC_NONE);
    printf("set $TK_TYPE=%d\n",TK_TYPE);
    printf("set $TKT_SYMBOL=%d\n",TKT_SYMBOL);
    printf("set $TKT_MARK=%d\n",TKT_MARK);
    printf("set $TKT_CONSTANT=%d\n",TKT_CONSTANT);
    printf("set $TKT_DYNAMIC=%d\n",TKT_DYNAMIC);
    printf("set $TK_FLAGS=%d\n",TK_FLAGS);
    printf("set $TKF_FREE=%d\n",TKF_FREE);
    printf("set $TK_INTEGER=%d\n",TK_INTEGER);
    printf("set $TK_BOUND_SYMBOL=%d\n",TK_BOUND_SYMBOL);
    printf("set $TK_BOUND_LITERAL=%d\n",TK_BOUND_LITERAL);
    printf("set $TK_UNBOUND_SYMBOL=%d\n",TK_UNBOUND_SYMBOL);
    printf("set $TK_UNBOUND_LITERAL=%d\n",TK_UNBOUND_LITERAL);
    printf("set $TK_MARK=%d\n",TK_MARK);
    printf("set $TK_TIME=%d\n",TK_TIME);
    printf("set $TK_STRING=%d\n",TK_STRING);
    printf("set $TK_ARRAY=%d\n",TK_ARRAY);
    printf("set $TK_PROCEDURE=%d\n",TK_PROCEDURE);
    printf("set $TK_FUNCTION=%d\n",TK_FUNCTION);
    printf("set $TK_DYNAMIC=%d\n",TK_DYNAMIC);
    printf("set $TK_REGEX=%d\n",TK_REGEX);
    printf("set $TK_DICT=%d\n",TK_DICT);
    printf("set $TK_UNDEF=%d\n\n",TK_UNDEF);
}


main(int argc, char **argv)
{
    int ch;
    char *uc;
    FILE *tfp;
    HashEntry *h;
    HashSearch hs;

    if (argc != 2) goto usage;
    if ((tfp= fopen(argv[1],"r")) == NULL)
    {
	fprintf(stderr,"%s: cannot open %s\n",argv[0],argv[1]);
	exit(1);
    }

    printf("# DO NOT EDIT THIS FILE\n");
    printf("# It is automatically generated by mkgdbinit.c from %s\n\n",argv[1]);
    printf("# This currently provides the following:\n");
    printf("#  - The \"ptok\" command prints a token in human readable form.\n");
    printf("#  - The $VAR_WHATEVER variables give system dict indexes.\n");
    printf("# EG:  do \"ptok sysdict[$VAR_AMFW].t\" to print value of \"amfw\"\n");

    typenames();
    init_sysdict();

    for (h= FirstHashEntry(&syshash, &hs); h != NULL; h= NextHashEntry(&hs))
    {
	if ((uc= ucname(h->key)) != NULL &&
	     class(h->t) != TKC_FUNCTION)
	    printf("set $VAR_%s=%d\n", uc, h-sysdict);
    }

    while ((ch= fgetc(tfp)) != EOF)
    	putchar(ch);

    exit(0);

usage:
    fprintf(stderr,"usage: %s <templatename>\n",argv[0]);
    exit(1);
}

/* Dummy this out */
void regfree(regex_t * r) {}
